import * as chai from 'chai';
import * as sinonChai from 'sinon-chai';
import * as sinon from 'sinon';
import * as referee from '@sinonjs/referee';
import { KubectlAPI } from '../../src/cli/kubectl-api';
import { CliCommand, CmdCli } from '../../src/cli/cmdCli';

import rewire = require('rewire');

const { assert } = referee;
const { expect } = chai;
chai.use(sinonChai);

suite('Kubectl CLI Command', () => {
  test('should create a proper command string', () => {
    const api = rewire('../../src/cli/kubectl-api');
    const kubectlCliCommand = api.__get__('kubectlCliCommand');
    const kubectlArguments: string[] = ['version', '--short', '--client'];
    const commandApi: CliCommand = kubectlCliCommand(kubectlArguments);
    const command: CliCommand = {
      cliArguments: ['version', '--short', '--client'],
      cliCommand: 'kubectl',
    };

    assert.equals(command, commandApi);
  });
});

suite('Kubectl API commands that will', () => {
  suite('Apply a file', () => {
    test('should apply a YAML file', () => {
      const command: CliCommand = {
        cliArguments: ['apply', '-f', './path.yaml'],
        cliCommand: 'kubectl',
      };
      const commandAPI = KubectlAPI.applyYAML('./path.yaml');
      assert.equals(command.cliArguments, commandAPI.cliArguments);
    });
  });

  suite('Print version', () => {
    test('should return command for printing the version of Kubectl', () => {
      const command: CliCommand = {
        cliArguments: ['version', '--short', '--client'],
        cliCommand: 'kubectl',
      };
      assert.equals(command.cliArguments, KubectlAPI.printVersion().cliArguments);
    });
  });

  const sandbox = sinon.createSandbox();

  teardown(() => {
    sandbox.restore();
  });

  suite('Get version', () => {
    test('should return the version number', async () => {
      sandbox.stub(CmdCli.getInstance(), 'execute').resolves({ error: undefined, stdout: 'Client Version: v1.18.3' });
      const version = await KubectlAPI.getKubectlVersion('path/to/kubectl');
      expect(version).equals('1.18.3');
    });
    test('should return Undefined when the version is not the correct text', async () => {
      sandbox.stub(CmdCli.getInstance(), 'execute').resolves({ error: undefined, stdout: 'not the version text' });
      const version = await KubectlAPI.getKubectlVersion('path/to/kubectl');
      expect(version).equals(undefined);
    });
    test('should return Undefined when the version is not returned', async () => {
      sandbox.stub(CmdCli.getInstance(), 'execute').resolves({ error: undefined, stdout: undefined });
      const version = await KubectlAPI.getKubectlVersion('path/to/kubectl');
      expect(version).equals(undefined);
    });
    test('should return Undefined for errors', async () => {
      sandbox.stub(CmdCli.getInstance(), 'execute').throws({ error: 'Error generated by a test', stdout: undefined });
      const version = await KubectlAPI.getKubectlVersion('path/to/kubectl');
      expect(version).equals(undefined);
    });
  });
});
